#Class对象
Class类也是一个实实在在的类，存在于JDK的java.lang包中,也是类的一种，与class关键字是不一样的。
手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，该Class对象保存在同名.class的文件中(即编译后得到的字节码文件)。
每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。
Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载
Class类的对象的作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要
反射就是在程序运行时借助Reflection API取得类的内部信息，来操作属性和方法。
#Java对象头
每个Java对象都有对象头。如果是⾮数组类型，则⽤2个字宽来存储对象头，如果是数组，则会⽤3个字宽来存储对象头。在32位处理器中，⼀个字宽是32位；在64位虚拟机中，⼀个字宽是64位。

在 JVM 中，对象在堆内存中的布局分为三块区域：对象头、实例变量和填充数据。
1️⃣【对象头区域】Java对象的对象头由 mark word 和 class pointer 两部分组成。
对象自身的运行时数据(MarkWord)。
存储 hashcode、GC 分代年龄、锁类型标记、偏向锁线程 ID、CAS 锁指向线程 LockRecord 的指针等，synchronized 锁的机制与这个部分(markwork)密切相关，用 markword 中最低的三位代表锁的状态，其中一位是偏向锁位，另外两位是普通锁位。
class pointer 存储对象的类型指针，该指针指向它的类元数据。
值得注意的是，如果应用的对象过多，使用 64 位的指针将浪费大量内存。64 位的 JVM 比 32 位的 JVM 多耗费 50% 的内存。
现在使用的 64 位 JVM 会默认使用选项+UseCompressedOops开启指针压缩，将指针压缩至 32 位。

2️⃣【实例数据区域】存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按 4 字节对齐。

3️⃣【对齐填充区域】JVM 的实现 HostSpot 规定对象的起始地址必须是 8 字节的整数倍，换句话来说，现在 64 bit/位 的 OS 往外读取数据的时候一次性读取 64 bit/位 整数倍的数据，也就是 8 个 byte/字节，所以 HotSpot 为了高效读取对象，就做了“对齐”，如果一个对象实际占用的内存大小不是 8 byte/字节 的整数倍时，就“补位”到 8 byte/字节 的整数倍。所以对齐填充区域的数据不是必须存在的，仅仅是为了字节对齐，当然大小也不是固定的。


锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。
随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。
偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀升级为轻量级锁。
“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。

 

Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized 效率低的原因。因此，这种依赖于操作系统Mutex Lock 所实现的锁我们称之为“重量级锁”。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。

每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针。不加 synchronized 的对象不会关联Monitor。

