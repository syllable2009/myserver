移位操作是把数据看作二进制数，然后将其向左或向右移动若干位的运算。在Java中，移位操作符包含三种：<<左移运算符，>>带符号右移运算符，>>>无符号右移运算符。这三种操作符都只能作用于long,int,short,byte这四种基本整形类型上和char类型上。其他类型如double都无法使用位运算符。
![image](https://github.com/syllable2009/myserver/blob/master/screenShots/simple-type.png)
在java中，第一位用来表示数字的正负，第一位为零时表示正数，第一位为1时表示负数。我们拿最简单的8位byte类型举例：0000 0000表示0，0111 1111这个表示最大值(2^8^-1)，再进行加一后就变成了1000 0000这时就变成了最小值(-2^8^)。再加一后变成1000 0001这时的值为-127。也就是从0到最大值然后转为最小值，然后再从最小值向零靠近。

#左移操作符<<
左移操作符<<是将数据转换为二进制后，向左移动若干位，高位丢弃，低位补零
        int a = 10;
        System.out.println("左移前的二进制:" Integer.toBinaryString(a));
        a <<= 2;
        System.out.println("左移后的二进制:" Integer.toBinaryString(a));
        System.out.println("左移后的十进制:" a);
首先定义一个数，值为10，打印它的二进制(1010)，然后进行左移操作2位。打印移位后的结果和二进制。40=10 2 2。所以一次左移等于将这个数扩大了两倍。        
        左移前的二进制:1010
        左移后的二进制:101000
        左移后的十进制:40
        int b = -8;
        左移前的二进制：11111111111111111111111111111000
        左移后的二进制：11111111111111111111111111100000
        左移后的十进制：-32 
可以明显的看出二进制向左移动了两位，前面的位置丢弃，后面的位置补零。转换为10进制也符合我们之前的运算：-32 = -8 2 2。
可以看出，将原来的二进制向左移动了两位，后面进行了补零。左移<<等于乘以2，右移>>等于除以2
#带符号右移操作符>>
刚才的左移中，它向左移动，高位进行了丢弃，低位进行补零。但是右移操作时有一个符号位，操作不当将造成答案与预期结果不同。
带符号右移就是在向右移动若干位，低位进行丢弃，高位按照符号位进行填补。对于正数做右移操作时，高位补充0；负数进行右移时，高位补充1。
   int a = 1024;
   System.out.println("a右移前的二进制："   Integer.toBinaryString(a));
   a >>= 4;
   System.out.println("a右移后的二进制："   Integer.toBinaryString(a));
   System.out.println("a右移后的十进制:" a);
   int b = -70336;
   System.out.println("b右移前的二进制："   Integer.toBinaryString(b));
   b >>= 4;
   System.out.println("b右移后的二进制："   Integer.toBinaryString(b));
   System.out.println("b右移后的十进制:" b);
   a右移前的二进制：10000000000
   a右移后的二进制：1000000
   a右移后的十进制:64
   b右移前的二进制：11111111111111101110110101000000
   b右移后的二进制：11111111111111111110111011010100
   b右移后的十进制:-4396
a原来的二进制向右移动后，低位被丢弃，高位补充符号位也就是0。b原来的二进制向右移动后，低位被丢弃，高位补充符号位1。这也符号我们之前的运算规律：1024 / 2^4^ =16 ；-70336/ 2^4^ = -4396。   

#无符号右移操作符>>>   
刚才的带符号右移操作符，我们在向右移动时带着高位的符号，正数填充0，负数填充0。现在不带符号的右移操作符大体与右移操作符一致，只不过不再区分正负数，结果都是高位补零，低位丢弃。
   int a = 1024;
   System.out.println("a右移前的二进制："   Integer.toBinaryString(a));
   a >>>= 4;
   System.out.println("a右移后的二进制："   Integer.toBinaryString(a));
   System.out.println("a右移后的十进制:" a);
   int b = -70336;
   System.out.println("b右移前的二进制："   Integer.toBinaryString(b));
   b >>>= 4;
   System.out.println("b右移后的二进制："   Integer.toBinaryString(b));
   System.out.println("b右移后的十进制:" b);
   确实正数没有变化，验证了我们的猜想。然后是负数，这次向右移动时高位进行了补零，低位丢弃。改变后的数值不再符合我们之前的规律。
   a右移前的二进制：10000000000
   a右移后的二进制：1000000
   a右移后的十进制:64
   b右移前的二进制：11111111111111101110110101000000
   b右移后的二进制：1111111111111110111011010100
   b右移后的十进制:268431060
在无符号右移中，当值为正数时，依然符合之前的规律移动一位相当于除以2。但是当值为负数时不再符合规律。

移位符是Java中的基本操作符，实际支持的类型只有int和long。在对byte,short,char类型进行移位操作时，都会先将其转换为int类型再进行操作。左移<<操作符相当于乘以2。带符号右移操作符>>相当于除以2。在Java中使用位运算符会比乘*,除/运算符更高效一些。而无符号右移符>>>在移动时高位补零，低位丢弃，在正数时仍然相当于除以2，但是在负数时结果却是变大了(由负数变为正数)。   