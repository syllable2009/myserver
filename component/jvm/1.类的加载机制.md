# 什么是类的加载
类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，
然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。
类的加载的最终产品是位于堆区中的 Class对象， Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
note:类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误

# 类的生命周期
加载的过程包括了[加载、验证、准备、解析、初始化]五个阶段。生命周期再加上[使用，卸载]在这五个阶段中，
加载、验证、准备和初始化这四个阶段发生的顺序是确定的，
而[解析阶段]则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。
另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。

#加载
 查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：
 通过一个类的全限定名来获取其定义的二进制字节流。
 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
 在Java堆中生成一个代表这个类的 java.lang.Class对象，作为对方法区中这些数据的访问入口。
 #连接[验证，准备，解析]
 #验证：确保被加载的类的正确性
 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：
 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。
 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
 符号引用验证：确保解析动作能正确执行。
 #准备：为类的静态变量分配内存，并将其初始化为默认值
 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：
 1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
 2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。
 假设一个类变量的定义为： publicstaticintvalue=3；
 那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的 publicstatic指令是在程序编译后，存放于类构造器 <clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。
 #解析：把类中的符号引用转换为直接引用
  解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。
  直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
  #初始化
   初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：
   ①声明类变量是指定初始值
   ②使用静态代码块为类变量指定初始值
   JVM初始化步骤
   1、假如这个类还没有被加载和连接，则程序先加载并连接该类
   2、假如该类的直接父类还没有被初始化，则先初始化其直接父类
   3、假如类中有初始化语句，则系统依次执行这些初始化语句
   类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：
   创建类的实例，也就是new的方式
   访问某个类或接口的静态变量，或者对该静态变量赋值
   调用类的静态方法
   反射（如 Class.forName(“com.shengsiyuan.Test”)）
   初始化某个类的子类，则其父类也会被初始化
   Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类
   #结束生命周期
   在如下几种情况下，Java虚拟机将结束生命周期
   执行了 System.exit()方法
   程序正常执行结束
   程序在执行过程中遇到了异常或错误而异常终止
   由于操作系统出现错误而导致Java虚拟机进程终止
  
# 类加载器   
站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：

启动类加载器： BootstrapClassLoader，负责加载存放在 JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被 -Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 BootstrapClassLoader加载）。启动类加载器是无法被Java程序直接引用的。
扩展类加载器： ExtensionClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader实现，它负责加载 JDK\jre\lib\ext目录中，或者由 java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。
应用程序类加载器： ApplicationClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。  

#双亲委派机制:
1、当 AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
2、当 ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader```去完成。
3、如果 BootStrapClassLoader加载失败（例如在 $JAVA_HOME/jre/lib里未查找到该class），会使用 ExtClassLoader来尝试加载；
4、若ExtClassLoader也加载失败，则会使用 AppClassLoader来加载，如果 AppClassLoader也加载失败，则会报出异常 ClassNotFoundException。 
双亲委派模型意义：
系统类防止内存中出现多份同样的字节码
保证Java程序安全稳定运行