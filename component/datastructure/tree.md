数据结构，指的是数据的存储形式，常见的有线性结构（数组、链表，队列、栈），还有非线性结构（树、图等）。

线性结构中，一个节点至多只有一个头节点，至多只有一个尾节点，彼此连接起来是一条完整的线。

而树，非线性结构的典型例子，不再是一对一，而变成了一对多

可以看到:
图中的结构就像一棵倒过来的树，最顶部的节点就是“根节点 (root 节点)”
每棵树至多只有一个根节点
根节点生出多个孩子节点，每个孩子节点只有一个父节点，每个孩子节点又生出多个孩子
父亲节点 (parent) 和孩子节点 (child) 是相对的
没有孩子节点的节点成为叶子节点 (leaf)

节点的度
一个节点直接含有的子树个数，叫做节点的度。比如上图中的 3 的度是 2，10 的度是 1。
树的度
一棵树中 最大节点的度，即哪个节点的子节点最多，它的度就是 树的度。上图中树的度为 2 。
节点的层次
从根节点开始算起，根节点算第一层，往后底层。比如上图中，3 的层次是 2，4 的层次是 4。
树的高度
树的高度是从叶子节点开始，自底向上增加。
树的深度
与高度相反，树的深度从根节点开始，自顶向下增加。
整个树的高度、深度是一样的，但是中间节点的高度 和 深度是不同的，比如上图中的 6 ，高度是 2 ，深度是 3。

#树的两种实现

从上述概念可以得知，树是一个递归的概念，从根节点开始，每个节点至多只有一个父节点，有多个子节点，每个子节点又是一棵树，以此递归。
树有两种实现方式：
数组：TreeNode[] arrayTree = new TreeNode[10]; 存储在db中的样子
链表：

树，为了更好的查找性能而生。
常见的树有以下几种分类：
二叉树：树中的任意一个节点，其左子树中的每个节点的值都小于该节点的值，右子树中的每个节点的值都大于该节点的值。
平衡二叉树:平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。
B 树
B+ 树
哈夫曼树：判定过程最优的二叉树为哈夫曼树，又称最优二叉树
堆：完全二叉树，物理存储上是数组。
红黑树

想必大家对二叉树搜索树都不陌生，首先看一下二叉搜索树的定义：
二叉搜索树（Binary Search Tree），或者是一棵空树，或者是具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。
123456某些情况下，二叉搜索树退化成了链表，这时候查询、插入和删除一个元素的时候，时间复杂度变成了O（n），显然这是不能接受的。出现这种情况情况的原因是二叉搜索树没有自平衡的机制，所以就有了平衡二叉树的概念。
红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。
平衡二叉树